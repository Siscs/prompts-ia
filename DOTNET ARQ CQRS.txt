
1. Exemplo de Prompt Customiz√°vel (.NET C#)

Atue como um desenvolvedor s√™nior .NET especializado em C#, DDD e Clean Architecture.

Crie uma solu√ß√£o .NET utilizando ASP.NET Core com Controllers (n√£o utilizar Minimal APIs),
seguindo os princ√≠pios de Clean Architecture e Domain-Driven Design (DDD).

Utilize os seguintes par√¢metros customiz√°veis:

- Nome da Solu√ß√£o: {{SolutionName}}
- Namespace raiz: {{RootNamespace}}
- Nome do projeto de API: {{ApiProjectName}}
- Nome do projeto de Application: {{ApplicationProjectName}}
- Nome do projeto de Domain: {{DomainProjectName}}
- Nome do projeto de Infrastructure: {{InfrastructureProjectName}}
- Contexto de dom√≠nio principal: {{BoundedContext}}
- Entidade principal: {{EntityName}}

### Estrutura desejada:
- {{ApiProjectName}}
  - Controllers
- {{ApplicationProjectName}}
  - Interfaces
  - UseCases
  - DTOs
- {{DomainProjectName}}
  - Entities
  - ValueObjects
  - Interfaces
- {{InfrastructureProjectName}}
  - Persistence
  - Repositories
  - Mappings

### Regras obrigat√≥rias:
- Utilizar namespaces baseados em {{RootNamespace}}
- As entidades devem ficar apenas no projeto Domain
- Reposit√≥rios devem ser definidos como interfaces no Domain
- Implementa√ß√µes de reposit√≥rio devem ficar na Infrastructure
- Controllers devem depender apenas da camada Application
- Usar Dependency Injection nativo do ASP.NET Core
- Utilizar padr√µes como Repository e Unit of Work quando aplic√°vel

### Entreg√°veis:
1. Estrutura de pastas e projetos
2. Exemplo de namespace completo para cada camada
3. Classe da entidade {{EntityName}} no Domain
4. Interface de reposit√≥rio no Domain
5. Implementa√ß√£o do reposit√≥rio na Infrastructure
6. Use Case (Application Service) para criar {{EntityName}}
7. Controller utilizando o Use Case
8. Exemplos de namespaces em todos os arquivos

Utilize C# moderno (.NET 8 ou superior) e boas pr√°ticas de c√≥digo.

----------------

Exemplo de uso do prompt (preenchido)

{{SolutionName}} = SalesManagement
{{RootNamespace}} = Company.Sales
{{ApiProjectName}} = Company.Sales.Api
{{ApplicationProjectName}} = Company.Sales.Application
{{DomainProjectName}} = Company.Sales.Domain
{{InfrastructureProjectName}} = Company.Sales.Infrastructure
{{BoundedContext}} = Orders
{{EntityName}} = Order

2. Prompt Base .NET C# ‚Äî Clean Architecture + DDD + CQRS

Atue como um desenvolvedor s√™nior .NET especializado em C#, DDD, Clean Architecture e CQRS.

Crie uma solu√ß√£o .NET utilizando ASP.NET Core com Controllers
(N√ÉO utilizar Minimal APIs),
seguindo Clean Architecture, Domain-Driven Design (DDD) e o padr√£o CQRS
(Command Query Responsibility Segregation).

Utilize os seguintes par√¢metros customiz√°veis:

- Nome da Solu√ß√£o: {{SolutionName}}
- Namespace raiz: {{RootNamespace}}
- Projeto de API: {{ApiProjectName}}
- Projeto de Application: {{ApplicationProjectName}}
- Projeto de Domain: {{DomainProjectName}}
- Projeto de Infrastructure: {{InfrastructureProjectName}}
- Bounded Context principal: {{BoundedContext}}
- Entidade principal: {{EntityName}}

---

## üìÅ Estrutura de projetos (obrigat√≥ria)

{{ApiProjectName}}
- Controllers
- DependencyInjection

{{ApplicationProjectName}}
- Abstractions
- Commands
  - Create{{EntityName}}
  - Update{{EntityName}}
- Queries
  - Get{{EntityName}}ById
  - Get{{EntityName}}List
- DTOs
- Behaviors (opcional ‚Äì pipeline)

{{DomainProjectName}}
- Entities
- ValueObjects
- Enums
- Interfaces
- Events

{{InfrastructureProjectName}}
- Persistence
- Repositories
- ReadModels
- Mappings

---

## üìê Regras arquiteturais obrigat√≥rias

- Todos os namespaces devem iniciar com {{RootNamespace}}
- A camada API depende apenas da Application
- A camada Application N√ÉO depende da Infrastructure
- A camada Domain N√ÉO depende de nenhuma outra camada
- A Infrastructure depende de Application e Domain
- CQRS:
  - Commands N√ÉO retornam entidades
  - Queries N√ÉO alteram estado
- Separar modelos de leitura (Read Models) quando necess√°rio
- Reposit√≥rios:
  - Interfaces no Domain
  - Implementa√ß√µes na Infrastructure
- Controllers:
  - Um controller por Aggregate Root
  - Controllers N√ÉO acessam reposit√≥rios diretamente
- Usar Dependency Injection nativo do ASP.NET Core
- Usar MediatR ou padr√£o equivalente para Commands e Queries

---

## üéØ Entreg√°veis esperados

1. Estrutura completa da solu√ß√£o
2. Exemplos de namespaces completos por camada
3. Entidade {{EntityName}} (Aggregate Root) no Domain
4. Evento de dom√≠nio (ex: {{EntityName}}CreatedEvent)
5. Interface de reposit√≥rio no Domain
6. Implementa√ß√£o do reposit√≥rio na Infrastructure
7. Command:
   - Create{{EntityName}}Command
   - Handler correspondente
8. Query:
   - Get{{EntityName}}ByIdQuery
   - Handler correspondente
9. DTOs usados em Commands e Queries
10. Controller utilizando Commands e Queries via MediatR
11. Registro de depend√™ncias (DI)

---

## üõ†Ô∏è Requisitos t√©cnicos

- .NET 8 ou superior
- C# moderno
- Controllers com atributos [ApiController]
- Usar async/await
- C√≥digo limpo, leg√≠vel e orientado a boas pr√°ticas

======================

Exemplo de par√¢metros preenchidos


{{SolutionName}} = CustomerManagement
{{RootNamespace}} = Company.Customers
{{ApiProjectName}} = Company.Customers.Api
{{ApplicationProjectName}} = Company.Customers.Application
{{DomainProjectName}} = Company.Customers.Domain
{{InfrastructureProjectName}} = Company.Customers.Infrastructure
{{BoundedContext}} = Customers
{{EntityName}} = Customer


3. Prompt Base ‚Äî .NET C# | Clean Architecture + DDD + CQRS (Handlers Manuais)

Atue como um desenvolvedor s√™nior .NET especializado em C#, DDD, Clean Architecture
e CQRS sem uso de MediatR ou qualquer biblioteca de mensageria.

Crie uma solu√ß√£o .NET utilizando ASP.NET Core com Controllers
(N√ÉO utilizar Minimal APIs),
seguindo os princ√≠pios de Clean Architecture, Domain-Driven Design (DDD)
e CQRS com handlers manuais.

---

## üîß Par√¢metros customiz√°veis

- Nome da Solu√ß√£o: {{SolutionName}}
- Namespace raiz: {{RootNamespace}}
- Projeto de API: {{ApiProjectName}}
- Projeto de Application: {{ApplicationProjectName}}
- Projeto de Domain: {{DomainProjectName}}
- Projeto de Infrastructure: {{InfrastructureProjectName}}
- Bounded Context principal: {{BoundedContext}}
- Aggregate Root / Entidade principal: {{EntityName}}

---

## üìÅ Estrutura obrigat√≥ria de projetos

{{ApiProjectName}}
- Controllers
- DependencyInjection

{{ApplicationProjectName}}
- Abstractions
  - Commands
  - Queries
- Commands
  - Create{{EntityName}}
  - Update{{EntityName}}
- Queries
  - Get{{EntityName}}ById
  - Get{{EntityName}}List
- DTOs

{{DomainProjectName}}
- Entities
- ValueObjects
- Enums
- Interfaces
- Events

{{InfrastructureProjectName}}
- Persistence
- Repositories
- ReadModels
- Mappings

---

## üìê Regras arquiteturais obrigat√≥rias

- Todos os namespaces devem iniciar com {{RootNamespace}}
- A camada API depende apenas da Application
- Application N√ÉO depende da Infrastructure
- Domain N√ÉO depende de nenhuma outra camada
- Infrastructure depende de Domain e Application
- CQRS:
  - Commands alteram estado e N√ÉO retornam entidades
  - Queries apenas retornam dados e N√ÉO alteram estado
- Separar modelos de escrita (Entities) e leitura (ReadModels)
- Reposit√≥rios:
  - Interfaces no Domain
  - Implementa√ß√µes na Infrastructure
- Handlers manuais:
  - Um handler por Command
  - Um handler por Query
  - Handlers expostos via interfaces
- Controllers:
  - N√ÉO acessam reposit√≥rios diretamente
  - Dependem apenas de handlers
- Usar Dependency Injection nativo do ASP.NET Core
- Usar async/await e CancellationToken

---

## üß© Padr√£o obrigat√≥rio para CQRS sem MediatR

### Commands
- Command (DTO de entrada)
- Interface: I{{CommandName}}Handler
- Implementa√ß√£o: {{CommandName}}Handler

### Queries
- Query (DTO de entrada)
- Interface: I{{QueryName}}Handler
- Implementa√ß√£o: {{QueryName}}Handler

---

## üéØ Entreg√°veis esperados

1. Estrutura completa da solu√ß√£o
2. Exemplo de namespaces completos por camada
3. Entidade {{EntityName}} como Aggregate Root
4. Evento de dom√≠nio (ex: {{EntityName}}CreatedEvent)
5. Interface de reposit√≥rio no Domain
6. Implementa√ß√£o do reposit√≥rio na Infrastructure
7. Command:
   - Create{{EntityName}}Command
   - Interface ICreate{{EntityName}}CommandHandler
   - Implementa√ß√£o Create{{EntityName}}CommandHandler
8. Query:
   - Get{{EntityName}}ByIdQuery
   - Interface IGet{{EntityName}}ByIdQueryHandler
   - Implementa√ß√£o Get{{EntityName}}ByIdQueryHandler
9. DTOs de leitura (ReadModels)
10. Controller consumindo handlers diretamente
11. Registro completo de depend√™ncias (DI)

---

## üõ†Ô∏è Requisitos t√©cnicos

- .NET 8 ou superior
- ASP.NET Core com Controllers
- C# moderno
- C√≥digo expl√≠cito, sem uso de reflection ou pipelines m√°gicos
- Alta legibilidade e baixo acoplamento

Exemplo de par√¢metros preenchidos

{{SolutionName}} = BillingSystem
{{RootNamespace}} = Company.Billing
{{ApiProjectName}} = Company.Billing.Api
{{ApplicationProjectName}} = Company.Billing.Application
{{DomainProjectName}} = Company.Billing.Domain
{{InfrastructureProjectName}} = Company.Billing.Infrastructure
{{BoundedContext}} = Invoices
{{EntityName}} = Invoice

4. Prompt Base ‚Äî .NET C# | Testes com xUnit + Moq (CQRS sem MediatR)

Atue como um desenvolvedor s√™nior .NET especializado em C#, testes automatizados,
xUnit, Moq, Clean Architecture, DDD e CQRS com handlers manuais.

Crie testes unit√°rios e de integra√ß√£o leve para a solu√ß√£o .NET descrita abaixo,
seguindo boas pr√°ticas de testes, isolamento de depend√™ncias e alta legibilidade.

---

## üîß Par√¢metros customiz√°veis

- Namespace raiz: {{RootNamespace}}
- Projeto de Application: {{ApplicationProjectName}}
- Projeto de Domain: {{DomainProjectName}}
- Projeto de Infrastructure: {{InfrastructureProjectName}}
- Projeto de Testes: {{TestsProjectName}}
- Bounded Context: {{BoundedContext}}
- Aggregate Root / Entidade: {{EntityName}}

---

## üìÅ Estrutura do projeto de testes

{{TestsProjectName}}
- Application
  - Commands
  - Queries
- Domain
- Infrastructure
- Fixtures
- Mocks
- Builders

---

## üìê Regras obrigat√≥rias de testes

- Utilizar xUnit como framework de testes
- Utilizar Moq para mockar depend√™ncias
- N√ÉO utilizar banco de dados real
- N√ÉO utilizar servi√ßos externos
- Testes devem ser:
  - Determin√≠sticos
  - Independentes
  - Nomeados no padr√£o: MethodName_Condition_ExpectedResult
- Cada teste deve validar apenas um comportamento
- Usar AAA pattern (Arrange, Act, Assert)

---

## üß© Escopo de testes obrigat√≥rios

### üü¶ Application Layer
- Testar Command Handlers:
  - Caso de sucesso
  - Valida√ß√µes de entrada
  - Regras de neg√≥cio
  - Intera√ß√£o com reposit√≥rios
- Testar Query Handlers:
  - Retorno correto dos dados
  - Comportamento quando n√£o h√° dados
- Mockar interfaces do Domain

---

### üü© Domain Layer
- Testar:
  - Cria√ß√£o da entidade {{EntityName}}
  - Regras de neg√≥cio
  - Invariantes
- N√ÉO mockar Domain

---

### üü® Infrastructure Layer
- Testar:
  - Implementa√ß√µes de reposit√≥rios
  - Mapeamentos
- Utilizar mocks para depend√™ncias externas

---

## üéØ Entreg√°veis esperados

1. Projeto de testes configurado
2. Refer√™ncias corretas para Application, Domain e Infrastructure
3. Testes unit√°rios para:
   - Create{{EntityName}}CommandHandler
   - Get{{EntityName}}ByIdQueryHandler
4. Testes de dom√≠nio para a entidade {{EntityName}}
5. Uso correto de Moq (Setup, Verify)
6. Uso de Fixtures e Builders para dados de teste
7. Exemplos claros de Arrange / Act / Assert
8. Cobertura de cen√°rios de sucesso e falha

---

## üõ†Ô∏è Requisitos t√©cnicos

- .NET 8 ou superior
- xUnit
- Moq
- FluentAssertions (opcional, se aplic√°vel)
- C√≥digo limpo, expl√≠cito e f√°cil de manter

Exemplo 
{{RootNamespace}} = Company.Billing
{{ApplicationProjectName}} = Company.Billing.Application
{{DomainProjectName}} = Company.Billing.Domain
{{InfrastructureProjectName}} = Company.Billing.Infrastructure
{{TestsProjectName}} = Company.Billing.Tests
{{BoundedContext}} = Invoices
{{EntityName}} = Invoice


5. Prompt Base ‚Äî .NET C# | Multi-Bounded Contexts

Atue como um desenvolvedor s√™nior .NET especializado em C#, DDD estrat√©gico,
Clean Architecture e CQRS com handlers manuais, trabalhando com m√∫ltiplos
Bounded Contexts na mesma solu√ß√£o.

Crie uma solu√ß√£o .NET organizada por Bounded Context,
mantendo isolamento de dom√≠nio, baixo acoplamento
e comunica√ß√£o expl√≠cita entre contextos.

---

## üîß Par√¢metros customiz√°veis

- Nome da Solu√ß√£o: {{SolutionName}}
- Namespace raiz: {{RootNamespace}}
- Projeto de API: {{ApiProjectName}}
- Projeto de Shared Kernel (opcional): {{SharedKernelProjectName}}
- Bounded Contexts:
  - {{BoundedContext1}}
  - {{BoundedContext2}}
  - {{BoundedContextN}}

Para cada Bounded Context:
- Entidade principal: {{EntityName}}
- Projeto Application
- Projeto Domain
- Projeto Infrastructure

---

## üß± Organiza√ß√£o da solu√ß√£o (obrigat√≥ria)

{{SolutionName}}
- src
  - {{ApiProjectName}}
  - SharedKernel (opcional)
  - {{BoundedContext1}}
    - {{BoundedContext1}}.Application
    - {{BoundedContext1}}.Domain
    - {{BoundedContext1}}.Infrastructure
  - {{BoundedContext2}}
    - {{BoundedContext2}}.Application
    - {{BoundedContext2}}.Domain
    - {{BoundedContext2}}.Infrastructure

- tests
  - {{BoundedContext1}}.Tests
  - {{BoundedContext2}}.Tests

---

## üìê Regras arquiteturais obrigat√≥rias

### Isolamento de Contextos
- Cada Bounded Context:
  - Possui seu pr√≥prio modelo de dom√≠nio
  - N√ÉO compartilha entidades com outros contextos
  - N√ÉO referencia diretamente Domain de outro contexto
- Comunica√ß√£o entre contextos deve ocorrer APENAS via:
  - Interfaces
  - Eventos de dom√≠nio ou integra√ß√£o
  - DTOs expl√≠citos

---

### Camadas (por contexto)

#### Domain
- Entidades
- Value Objects
- Regras de neg√≥cio
- Eventos de dom√≠nio
- Interfaces (ex: reposit√≥rios)

#### Application
- Commands
- Queries
- Handlers manuais
- DTOs
- Portas de entrada e sa√≠da

#### Infrastructure
- Persist√™ncia
- Reposit√≥rios
- Integra√ß√µes externas
- Read Models

---

## üîÄ Comunica√ß√£o entre Bounded Contexts

- N√ÉO usar refer√™ncias diretas entre Domains
- Preferir:
  - Domain Events ‚Üí Integration Events
  - Anti-Corruption Layer (ACL)
- Cada contexto deve traduzir dados externos para seu pr√≥prio modelo

---

## üß© Padr√µes obrigat√≥rios (CQRS sem MediatR)

### Commands
- {{Action}}{{EntityName}}Command
- I{{Action}}{{EntityName}}CommandHandler
- {{Action}}{{EntityName}}CommandHandler

### Queries
- Get{{EntityName}}ByIdQuery
- IGet{{EntityName}}ByIdQueryHandler
- Get{{EntityName}}ByIdQueryHandler

---

## üéØ Entreg√°veis esperados

1. Estrutura completa da solu√ß√£o multi-bounded contexts
2. Exemplo de namespaces completos por contexto
3. Entidade principal de cada Bounded Context
4. Commands e Queries por contexto
5. Handlers manuais por contexto
6. Comunica√ß√£o entre contextos via eventos ou interfaces
7. Controllers organizados por contexto
8. Registro de depend√™ncias por contexto
9. Exemplo de Anti-Corruption Layer
10. Projeto de testes por Bounded Context

---

## üõ†Ô∏è Requisitos t√©cnicos

- .NET 8 ou superior
- ASP.NET Core com Controllers
- CQRS com handlers expl√≠citos
- Sem uso de MediatR
- Alta coes√£o dentro do contexto
- Baixo acoplamento entre contextos

Exemplo de uso (preenchido)
{{SolutionName}} = CommerceSystem
{{RootNamespace}} = Company.Commerce
{{ApiProjectName}} = Company.Commerce.Api
{{SharedKernelProjectName}} = Company.Commerce.SharedKernel

{{BoundedContext1}} = Orders
{{EntityName}} = Order

{{BoundedContext2}} = Billing
{{EntityName}} = Invoice

6. 